<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE nta PUBLIC '-//Uppaal Team//DTD Flat System 1.6//EN' 'http://www.it.uu.se/research/group/darts/uppaal/flat-1_6.dtd'>
<nta>
	<declaration>/* error detection */
int8_t some_array[1] = { 0 };
void panic() { some_array[2] = 1; }
void todo() { panic(); }

/* Potential known problems:
 * 1. "add" and "addi" (most likely more) allows overflow
 *        which we currently do not. This may cause some issues in the future.
 * 2. All operations are implemented with signed extensions which may cause
 *        unintential side-effects when unsigned arithmetic should be used
 */

/* Values for attacker */
const int MAX_FLIPS = 1;
int flips = MAX_FLIPS;

// Data filled in but auto-generator:
typedef struct {
    int32_t code;
    // Mostly always the "rd" register.
    int32_t op1;
    int32_t op2;
    // Mostly always an offset.
    int32_t op3;
} instruction_t;

// The memory available to the program.
// Data: This includes global variables and static variables. 
// Heap: The heap grows upward (toward higher memory addresses) as dynamic
//    memory allocations (e.g., malloc in C) occur.
//     The heap starts right after the global/static data section.
// Stack: The stack grows downward (toward lower memory addresses). It is typically placed at the
//    top of the memory space and moves down as functions call and allocate local variables.
// Ergo. the stack starts at the greatest index. The data starts at
//    the smallest index. The heap starts right after the data.
const int32_t MEMORY_LENGTH = 256;
typedef int[0, MEMORY_LENGTH] address_t;
uint8_t memory[MEMORY_LENGTH];

/* Generated: Program segment */
const int32_t PROGRAM_LENGTH = 8;
instruction_t program[PROGRAM_LENGTH];

// The program counter (PC) to keep track of which instruction to execute.
typedef int[0, PROGRAM_LENGTH] pc_t;
pc_t pc = 0;

/* Generated: PC labels */
const pc_t L0 = 0;
/* Generated: Global variable addresses */
const address_t g_authenticated = 0;

/* Documentation */
// https://gse.ufsc.br/bezerra/wp-content/uploads/2022/04/Lecture7.pdf
// https://www.cs.sfu.ca/~ashriram/Courses/CS295/assets/notebooks/RISCV/RISCV_CARD.pdf
typedef int[0, 20] opcode_t;
const opcode_t ADDI_CODE = 0;
const opcode_t   SW_CODE = 1;
const opcode_t   LW_CODE = 2;
const opcode_t  LUI_CODE = 3;
const opcode_t   SB_CODE = 4;
const opcode_t    J_CODE = 5;  // Pseudo-instruction. We assume that it is always to a lable (op3).
const opcode_t   LI_CODE = 6;  // Pseudo-instruction.
const opcode_t   LB_CODE = 7;
const opcode_t  BLE_CODE = 8;  // Pseudo-instruction. We assume that it is always to a lable (op3).
const opcode_t  BEQ_CODE = 9;  // We assume that it is always to a lable (op3).
const opcode_t  NOP_CODE = 10;
const opcode_t ANDI_CODE = 11;
const opcode_t SLLI_CODE = 12;
const opcode_t SRAI_CODE = 13;
const opcode_t  ADD_CODE = 14;
const opcode_t  LBU_CODE = 15;
const opcode_t  BNE_CODE = 16;
const opcode_t   MV_CODE = 17; // Pseudo-instruction.
const opcode_t   JR_CODE = 18; // Pseudo-instruction.
const opcode_t SEQZ_CODE = 19; // Pseudo-instruction.
const opcode_t  BLT_CODE = 20; // We assume that it is always to a lable (op3).

/* CPU Registers "https://msyksphinz-self.github.io/riscv-isadoc/html/regs.html" */
typedef int[0, 31] register_t;
const register_t zero = 0;
const register_t ra = 1;
const register_t sp = 2;
const register_t gp = 3;
const register_t tp = 4;
const register_t t0 = 5;
const register_t t1 = 6;
const register_t t2 = 7;
const register_t s0 = 8;
const register_t s1 = 9;
const register_t a0 = 10;
const register_t a1 = 11;
const register_t a2 = 12;
const register_t a3 = 13;
const register_t a4 = 14;
const register_t a5 = 15;
const register_t a6 = 16;
const register_t a7 = 17;
const register_t s2 = 18;
const register_t s3 = 19;
const register_t s4 = 20;
const register_t s5 = 21;
const register_t s6 = 22;
const register_t s7 = 23;
const register_t s8 = 24;
const register_t s9 = 25;
const register_t s10 = 26;
const register_t s11 = 27;
const register_t t3 = 28;
const register_t t4 = 29;
const register_t t5 = 30;
const register_t t6 = 31;
int32_t registers[32];

int32_t symbol_low(int32_t symbol) {
    return symbol &amp; 4095; // The low 12 bits of the symbol.
}

int32_t symbol_high(int32_t symbol) {
    return symbol &amp; -4096; // The high 20 bits of the symbol.
}

instruction_t instruction;

void fetch() {
    instruction = program[pc];
    pc += 1;
}

void execute() {
    if (instruction.code == ADDI_CODE) {
        // Implementation: reg[op1] = reg[op2] + op3
        // Example: "addi a5,a4,1" op1=a5 op2=a4 op3=1
        registers[instruction.op1] = registers[instruction.op2] + instruction.op3;
    } else if (instruction.code == SW_CODE) {
        // Implementation: mem[reg[op2] + op3] = reg[op1]
        // Example: "sw a5,-20(s0)" op1=a5 op2=s0 op3=-20
        memory[registers[instruction.op2] + 0 + instruction.op3] = (registers[instruction.op1] &gt;&gt; 0)  &amp; 255;
        memory[registers[instruction.op2] + 1 + instruction.op3] = (registers[instruction.op1] &gt;&gt; 8)  &amp; 255;
        memory[registers[instruction.op2] + 2 + instruction.op3] = (registers[instruction.op1] &gt;&gt; 16) &amp; 255;
        memory[registers[instruction.op2] + 3 + instruction.op3] = (registers[instruction.op1] &gt;&gt; 24) &amp; 255;
    } else if (instruction.code == LW_CODE) {
        // Implementation: reg[op1] = mem[reg[op2] + op3]
        // Example: "lw a5,-24(s0)" op1=a5 op2=s0 op3=-24
        registers[instruction.op1] = (memory[registers[instruction.op2] + 0 + instruction.op3] &lt;&lt; 0)  |
                                     (memory[registers[instruction.op2] + 1 + instruction.op3] &lt;&lt; 8)  |
                                     (memory[registers[instruction.op2] + 2 + instruction.op3] &lt;&lt; 16) |
                                     (memory[registers[instruction.op2] + 3 + instruction.op3] &lt;&lt; 24);
    } else if (instruction.code == LUI_CODE) {
        // Implementation: reg[op1] = op2
        // Example: "lui a5,%hi(g_ptc)" op1=a5 op2=symbol_high(g_ptc)
        registers[instruction.op1] = instruction.op2;
    } else if (instruction.code == SB_CODE) {
        // Implementation: mem[reg[op2] + op3 = op1
        // Example: "a4,%lo(g_ptc)(a5)" op1=a4 op2=a5 op3=symbol_low(g_ptc)
        memory[registers[instruction.op2] + instruction.op3] = instruction.op1;
    } else if (instruction.code == J_CODE) {
        // Note: This is a pseudo-instruction.
        // Implementation: pc = lab[op1]
        // Example: "j .L6" op1=L6
        // We assume that the labels point directly to the pc to jump to.
        pc = instruction.op1;
    } else if (instruction.code == LI_CODE) {
        // Note: This is a pseudo-instruction.
        // Implementation: reg[op1] = op2
        // Example: "li a5,85" op1=a5 op2=85
        registers[instruction.op1] = instruction.op2;
    } else if (instruction.code == LB_CODE) {
        // Implementation: reg[op1] = mem[reg[op2] + op3]
        // Example: "a5,%lo(g_ptc)(a5)" op1=a5 op2=a5 op3=symbol_low(g_ptc)
        registers[instruction.op1] = memory[registers[instruction.op2] + instruction.op3];
    } else if (instruction.code == BLE_CODE) {
        // Note: This is a pseudo-instruction.
        // Implementation: if reg[op1] &lt; reg[op2] then pc = lab[op3]
        // Example: "ble a4,a5,.L9" op1=a4 op2=a5 op3=L9
        if (registers[instruction.op1] &lt; registers[instruction.op2]) {
            // We assume that the labels point directly to the pc to jump to.
            pc = instruction.op3;
        }
    } else if (instruction.code == BEQ_CODE) {
        // Implementation: if reg[op1] = reg[op2] then pc = lab[op3]
        // Example: "beq a4,a5,.L3" op1=a4 op2=a5 op3=L3
        if (registers[instruction.op1] == registers[instruction.op2]) {
            // We assume that the labels point directly to the pc to jump to.
            pc = instruction.op3;
        }
    } else if (instruction.code == NOP_CODE) {
        // Implementation: zzzZZZ
        // Example: "nop"
    } else if (instruction.code == ANDI_CODE) {
        // Implementation: reg[op1] = reg[op2] &amp; op3
        // Example: "andi a5,a3,0xff" op1=a5 op2=a3 op3=0xff
        registers[instruction.op1] = registers[instruction.op2] &amp; instruction.op3;
    } else if (instruction.code == SLLI_CODE) {
        // Implementation: reg[op1] = reg[op2] &lt;&lt; op3
        // Example: "slli a4,a5,24" op1=a4 op2=a5 op3=24
        registers[instruction.op1] = registers[instruction.op2] &lt;&lt; instruction.op3;
    } else if (instruction.code == SRAI_CODE) {
        // Implementation: reg[op1] = reg[op2] &gt;&gt; op3
        // Example: "srai a4,a2,24" op1=a4 op2=a2 op3=24
        registers[instruction.op1] = registers[instruction.op2] &gt;&gt; instruction.op3;
    } else if (instruction.code == ADD_CODE) {
        // Implementation: reg[op1] = reg[op2] + op3
        // Example: "add a5,a4,a5" op1=a5 op2=a4 op3=a5
        registers[instruction.op1] = registers[instruction.op2] + instruction.op3;
    } else if (instruction.code == LBU_CODE) {
        // Implementation: reg[op1] = mem[reg[op2] + op3]
        // Example: "lbu a4,-26(s0)" op1=a4 op2=s0 op3=-26
        registers[instruction.op1] = memory[registers[instruction.op2] + instruction.op3];
    } else if (instruction.code == BNE_CODE) {
        // Implementation: if reg[op1] != reg[op2] then pc = lab[op3]
        // Example: "bne a4,a5,.L18" op1=14 op2=a5 op3=L18
        if (registers[instruction.op1] != registers[instruction.op2]) {
            // We assume that the labels point directly to the pc to jump to.
            pc = instruction.op3;
        }
    } else if (instruction.code == MV_CODE) {
        // Note: This is a pseudo-instruction.
        // Implementation: reg[op1] = reg[op2]
        // Example: "mv a0,a5" op1=a0 op2=a5
        registers[instruction.op1] = registers[instruction.op2];
    } else if (instruction.code == JR_CODE) {
        // Note: This is a pseudo-instruction.
        // Implementation: pc = reg[op1]
        // Example: "jr ra" op1=ra
        pc = registers[instruction.op1];
    } else if (instruction.code == SEQZ_CODE) {
        // Note: This is a pseudo-instruction.
        // Implementation: if op2 == 0 then reg[op1] = 1 else reg[op1] = 0
        // Example: "seqz a5,a4" op1=a5 op2=a4
        if (registers[instruction.op2] == 0) {
            registers[instruction.op1] = 1;
        } else {
            registers[instruction.op1] = 0;
        }
    } else if (instruction.code == BLT_CODE) {
        // Implementation: if reg[op1] &lt; reg[op2] then pc = lab[op3]
        // Example: "blt a4,a5,.L5" op1=a4 op2=a5 op3=L5
        if (registers[instruction.op1] &lt; registers[instruction.op2]) {
            // We assume that the labels point directly to the pc to jump to.
            pc = instruction.op3;
        }
    } else {
        panic(); // Unknown instruction type.
    }
}</declaration>
	<template>
		<name x="5" y="5">VM</name>
		<declaration>// Automatically generated.

void setup() {
    instruction_t line_0 = {ADDI_CODE, sp, sp, -32};                         // J1: addi sp sp 32
    instruction_t line_1 = {ADDI_CODE, ra, ra, -1430532899};                 // addi ra ra 0xAABBCCDD
    instruction_t line_2 = {SW_CODE, ra, sp, -20};                           // sw ra (-20)sp
    instruction_t line_3 = {LW_CODE, tp, sp, -20};                           // lw tp (-20)sp
    instruction_t line_4 = {SW_CODE, ra, 0, 0};                              // sw ra (-20)sp
    instruction_t line_5 = {LUI_CODE, a5, symbol_high(g_authenticated), 0};  // lui a5,%hi(g_authenticated)
    instruction_t line_6 = {SB_CODE, zero, a5, symbol_low(g_authenticated)}; // sb zero,%lo(g_authenticated) + (a5)
    instruction_t line_7 = {J_CODE, L0, 0, 0};                               // j L1

    // Init stack pointer (base).
    registers[sp] = MEMORY_LENGTH - 1;
    pc = 0;

    program[0] = line_0;
    program[1] = line_1;
    program[2] = line_2;
    program[3] = line_3;
    program[4] = line_4;
    program[5] = line_5;
    program[6] = line_6;
    program[7] = line_7;
}</declaration>
		<location id="id0" x="-629" y="68">
		</location>
		<location id="id1" x="-527" y="68">
		</location>
		<location id="id2" x="-739" y="68">
			<committed/>
		</location>
		<init ref="id2"/>
		<transition id="id3">
			<source ref="id2"/>
			<target ref="id0"/>
			<label kind="assignment" x="-714" y="51">setup()</label>
		</transition>
		<transition id="id4">
			<source ref="id1"/>
			<target ref="id0"/>
			<label kind="assignment" x="-612" y="110">execute()</label>
			<nail x="-527" y="110"/>
			<nail x="-629" y="110"/>
		</transition>
		<transition id="id5">
			<source ref="id0"/>
			<target ref="id1"/>
			<label kind="guard" x="-663" y="0">pc &lt; PROGRAM_LENGTH</label>
			<label kind="assignment" x="-612" y="17">fetch()</label>
			<nail x="-629" y="34"/>
			<nail x="-527" y="34"/>
		</transition>
	</template>
	<template>
		<name>register_corruption</name>
		<declaration>register_t register;


int pwr(int num, int pwr){
    int res = 1;
    if(pwr == 0)
        return res;
    while(pwr &gt; 0){
        res = res * num;
        pwr--;
    }
    return res;
}</declaration>
		<location id="id6" x="-170" y="8">
		</location>
		<location id="id7" x="68" y="8">
			<committed/>
		</location>
		<init ref="id6"/>
		<transition id="id8">
			<source ref="id6"/>
			<target ref="id7"/>
			<label kind="select" x="-144" y="-51">reg : register_t</label>
			<label kind="guard" x="-144" y="-34">flips &gt; 0</label>
			<label kind="assignment" x="-144" y="-17">register = reg, flips--</label>
		</transition>
		<transition id="id9">
			<source ref="id7"/>
			<target ref="id6"/>
			<label kind="select" x="-170" y="60">flip_val : int[0,8]</label>
			<label kind="assignment" x="-170" y="77">registers[register] = registers[register] ^ pwr(2, flip_val)</label>
			<nail x="68" y="51"/>
			<nail x="-170" y="51"/>
		</transition>
	</template>
	<template>
		<name>pc_corruption</name>
		<declaration>int[-8, 8] flip_val;</declaration>
		<location id="id10" x="-136" y="0">
		</location>
		<location id="id11" x="229" y="0">
		</location>
		<init ref="id10"/>
		<transition id="id12">
			<source ref="id11"/>
			<target ref="id10"/>
			<label kind="guard" x="-119" y="170">flip_val &gt; PROGRAM_LENGTH</label>
			<label kind="assignment" x="-119" y="187">pc = PROGRAM_LENGTH</label>
			<nail x="229" y="204"/>
			<nail x="-136" y="204"/>
		</transition>
		<transition id="id13">
			<source ref="id11"/>
			<target ref="id10"/>
			<label kind="guard" x="-119" y="93">0 &lt; flip_val &amp;&amp; flip_val &lt; PROGRAM_LENGTH</label>
			<label kind="assignment" x="-119" y="110">pc = flip_val</label>
			<nail x="229" y="127"/>
			<nail x="-136" y="127"/>
		</transition>
		<transition id="id14">
			<source ref="id11"/>
			<target ref="id10"/>
			<label kind="guard" x="-119" y="34">flip_val &lt; 0</label>
			<label kind="assignment" x="-119" y="51">pc = 0</label>
			<nail x="229" y="68"/>
			<nail x="-136" y="68"/>
		</transition>
		<transition id="id15">
			<source ref="id10"/>
			<target ref="id11"/>
			<label kind="select" x="-119" y="-59">choice : int[-8, 8]</label>
			<label kind="guard" x="-119" y="-42">flips &gt; 0</label>
			<label kind="assignment" x="-119" y="-25">flip_val = choice, flips--</label>
		</transition>
	</template>
	<template>
		<name>instruction_corruption</name>
		<location id="id16" x="17" y="0">
			<committed/>
		</location>
		<location id="id17" x="127" y="0">
			<name x="127" y="-34">flipping_code</name>
			<committed/>
		</location>
		<location id="id18" x="-178" y="-85">
			<name x="-289" y="-102">flipping_op1</name>
			<committed/>
		</location>
		<location id="id19" x="17" y="85">
			<name x="25" y="59">flipping_op2</name>
			<committed/>
		</location>
		<location id="id20" x="-195" y="-127">
			<name x="-187" y="-161">flipping_op3</name>
			<committed/>
		</location>
		<location id="id21" x="-178" y="0">
		</location>
		<init ref="id21"/>
		<transition id="id22">
			<source ref="id21"/>
			<target ref="id16"/>
			<label kind="guard" x="-161" y="-17">flips &gt; 0</label>
			<label kind="assignment" x="-160" y="0">flips--</label>
		</transition>
		<transition id="id23">
			<source ref="id19"/>
			<target ref="id21"/>
			<label kind="select" x="-170" y="51">num : int[-8, 8]</label>
			<label kind="assignment" x="-170" y="68">instruction.op2 = num</label>
			<nail x="-110" y="85"/>
			<nail x="-178" y="85"/>
		</transition>
		<transition id="id24">
			<source ref="id20"/>
			<target ref="id21"/>
			<label kind="select" x="-390" y="-170">num : int[-8, 8]</label>
			<label kind="assignment" x="-390" y="-153">instruction.op3 += num</label>
			<nail x="-399" y="-127"/>
			<nail x="-399" y="0"/>
		</transition>
		<transition id="id25">
			<source ref="id16"/>
			<target ref="id20"/>
			<nail x="59" y="-34"/>
			<nail x="59" y="-127"/>
		</transition>
		<transition id="id26">
			<source ref="id19"/>
			<target ref="id21"/>
			<label kind="select" x="-170" y="119">reg : register_t</label>
			<label kind="assignment" x="-170" y="136">instruction.op2 = reg</label>
			<nail x="17" y="161"/>
			<nail x="-178" y="161"/>
		</transition>
		<transition id="id27">
			<source ref="id16"/>
			<target ref="id19"/>
		</transition>
		<transition id="id28">
			<source ref="id18"/>
			<target ref="id21"/>
			<label kind="select" x="-348" y="-68">reg : register_t</label>
			<label kind="assignment" x="-348" y="-51">instruction.op1 = reg</label>
		</transition>
		<transition id="id29">
			<source ref="id16"/>
			<target ref="id18"/>
			<nail x="17" y="-85"/>
		</transition>
		<transition id="id30">
			<source ref="id17"/>
			<target ref="id21"/>
			<label kind="select" x="135" y="85">op : opcode_t</label>
			<label kind="assignment" x="135" y="102">instruction.code = op</label>
			<nail x="127" y="204"/>
			<nail x="-195" y="204"/>
			<nail x="-195" y="42"/>
		</transition>
		<transition id="id31">
			<source ref="id16"/>
			<target ref="id17"/>
		</transition>
	</template>
	<template>
		<name>memory_corruption</name>
		<location id="id32" x="0" y="0">
		</location>
		<init ref="id32"/>
	</template>
	<system>// Place template instantiations here.
vm = VM();
// List one or more processes to be composed into a system.
system vm, register_corruption;
</system>
	<queries>
		<query>
			<formula/>
			<comment>// Just to make sure that the VM does not have any internal logic errors.</comment>
		</query>
		<query>
			<formula>E&lt;&gt; !vm.test_failure</formula>
			<comment/>
		</query>
	</queries>
</nta>
